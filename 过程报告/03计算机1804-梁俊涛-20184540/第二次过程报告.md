# 编译第二次过程报告

## 3. 编译系统整体设计

### 3.1 整体设计流程图

![image-20200703151218432](C:\Users\无趣先生\AppData\Roaming\Typora\typora-user-images\image-20200703151218432.png)

### 3.2 中间代码生成(LR（0））

#### 3.2.1 功能

- 1.构建语义
- 2.重新导入二元式
- 3.获取动作序列
- 4.初始化四元式
- 5.获取动作序列位置
- 6.在已有动作序列的基础上生成四元式（自底向上）
- 7输出四元式
- 8.四元式的预处理及优化

#### 3.2.2 数据结构

struct quaternion {
int actid；
char id1[15]；
char id2[15]；
type type1；
type type2；
char id3[15]；

};

struct actsequence{
char name[15]；
char value1[15]；
float value2；
};

actsequence actionseq[100];

char actid[20][10]=
{"+"，"-"，"*”，"/"，">"，"<”，">="，"<="，"=="，"="，"if"，"else"，"ie"，
"while"，"do"，"we"，"return"，"cout"，"cin"，"#}；

int sem[1000];

#### 3.2.3 流程图

![image-20200709110856790](C:\Users\无趣先生\AppData\Roaming\Typora\typora-user-images\image-20200709110856790.png)

#### 3.2.4 算法

对四元式以及语义栈进行初始化之后根据语义动作生成对应的四元式，其中的动作我利用动作标号来进行表示，枚举出包含的语义动作，然后根据相应的语义动作进行相应的四元式生成。我原本的最开始的方法是先生成逆波兰式，然后将逆波兰式转化为四元式的方式。但是不适合我们整体编译器，然后我又用递归子程序做了一个，在拼接的时候出现了问题。由于组长做的语法分析器是LL1，并没有递归子程序函数，所以最后我采用了现在的方法。

### 3.3 目标代码生成

#### 3.3.1流程图

![image-20200709131108129](C:\Users\无趣先生\AppData\Roaming\Typora\typora-user-images\image-20200709131108129.png)

#### 3.3.2设计思想

进入目标代码生成后首先对符号表预处理，然后对四元式预处理，调用四元式优化。

然后正式开始目标代码生成，打开优化完成的四元式文件后，依次读入四元式，同时打开目标代码文件，向其中写入目标代码。

首先是通过符号表填写定义变量以及汇编语言预置部分代码。

然后开始读取四元式，判断四元式的类型，赋值语句，输入输出，逻辑表达式，算术表达式等等并通过判断数据类型，然后将他们翻译成目标代码，反之若类型不匹配则报错。

## 4. 程序设计与实现

### 4.1 程序说明

本程序实现的数据类型有整型（int）、浮点型（float）、char（字符型）、字符串型（string），同时在最后的目标代码生成部分允许出现布尔（bool）类型，实现的操作有if，else以及while循环，和输入输出语句，能做到直接生成目标代码并运行。做到了类型检查和重定义的判断，同时也有优化部分。

中间代码生成部分，在语法分析部分生成了一个具体可理解的动作序列，中间代码生成采取的是自底向上进行分析，基于单词序列进行的分析，其操作是使用已获得的伪动作序列，与源程序去作比较，找出伪动作序列的实际含义，将其顺序填好，最后便完成了整个中间代码（四元式）的生成，并将其重新输出到文件中。

目标代码生成部分较长，也并不仅仅包含目标代码生成部分，在这个部分文件中，同时需要对前述获得的符号表，中间代码进行再处理，以得到符号目标代码生成所用的符号表和中间代码，再进行预处理完成之后，具体为根据四元式动作，按顺序依次生成目标代码，需要依据不同的四元式动作每个采取不同的操作方法，生成相应目标代码。

### 4.2 实验结果

![image-20200709131809038](C:\Users\无趣先生\AppData\Roaming\Typora\typora-user-images\image-20200709131809038.png)

![image-20200709131848066](C:\Users\无趣先生\AppData\Roaming\Typora\typora-user-images\image-20200709131848066.png)

## 5. 收获、体会和建议

​		在前端基本完成之后，我们组一起进行了目标代码的编写，我们选择了汇编语言进行编写，包含了赋值语句基本的逻辑判断以及ifwhile等等操作，因为时间太紧迫，整体设计还比较简单需要完善的地方还有很多。我自己的语义分析部分总体也是完成了一些简单的四元式生成，也还有很大的优化空间。这次的课设让我学会了不一样的协作方式，这次的课设教会了我使用GIT，也教会了我在课设编码之前应该先统筹规划好，才能更加有效率的完成任务。团队成员之间的互相帮助和交流也让我明白一群人的力量比一个人的力量大得多，你不会的别人可能会，别人不会的你会，互相学习的过程使得我们团队不仅合作氛围愉快，效率也更加高。
