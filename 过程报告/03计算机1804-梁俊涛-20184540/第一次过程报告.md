# 编译第一次过程报告

------

## 设计分工：

组长学号及姓名：20184317彭明均

分工：文法设计、数据结构设计、语法分析（LL1）、基于DAG的中间代码优化、部分目标代码生成

组员1学号及姓名：20184454谢一帆

分工：文法设计、符号表组织、部分目标代码生成

组员2学号及姓名：20184540梁俊涛

分工：文法设计、中间代码生成（LR0）、部分目标代码生成

组员3学号及姓名：20184390杨子江

分工：文法设计、词法分析、部分目标代码生成



## 1. 摘要

​		编译器是一个便于人编写、阅读和维护的高级计算机语言翻译为计算机能解读、运行的低阶机器语言或者汇编语言的程序。编译是从源代码（通常为高级语言）到能直接被计算机或者虚拟机执行的目标代码（通常为汇编语言或者机器语言）的翻译过程。

 - 编译器的概念

   ​		编译器是一个便于人编写、阅读和维护的高级计算机语言翻译为计算机能解读、运行的低阶机器语言或者汇编语言的程序。编译器将源程序作为输入，翻译产生使用目标语言的等价程序。源代码一般为高级语言，而目标代码则是汇编语言或者机器语言。

 - 编译器的种类

   ​		编译器可以生成用来在与编译器本身所在的计算机和操作系统相同的环境下运行的目标代码，这种编译器又叫做“本地”编译器。另外，编译器也可以生成用来在其他平台上运行的目标代码，这种编译器又叫做交叉编译器。交叉编译器在生成新的硬件平台时非常有用。“源码到源码编译器”是指用一种高级语言作为输入，输出也是高级语言的编译器。

 - 本编译器的相关概述

   ​		编译程序的工作一般可以分为五个阶段：词法分析、语法分析、语义分析、中间代码产生和优化、目标代码生成。每个阶段又在功能上是相对独立的，它一方面从上一阶段获取分析的结果来进行分析，另一方面又将结果传送给下一阶段。由编译程序的五个阶段就对应了编译系统的结构，这五个对应阶段分为编译器的前端和后端。

   ​		语法分析器将词法分析的结果作为输入，并对其进行语法分析。本编译器语法分析采用LL(1)分析法，语法分析器把语法单元作为输出供语义分析器来使用。

- 环境

  Visual  Studio 2019

- 目标代码

  8086汇编语言

  

## 2. 课程设计任务及要求

### 2.1 设计任务

- 在下列内容中任选其一：

  - 一个简单文法的编译器前端的设计与实现。
  - 一个简单文法的编译器后端的设计与实现。
  - 一个简单文法的编译器的设计与实现。
  - 自选一个感兴趣的与编译原理有关的问题加以实现，要求难度相当。

- 本组选择题目：

  **一个简单文法的编译器的设计与实现。**

  - 定义一个简单程序设计语言文法

  - 扫描器设计实现

  - 语法分析器设计实现

  - 符号表设计

  - 符号表生成器设计

  - 中间代码设计

  - 中间代码生成器设计

  - 中间代码优化

  - 中间代码优化实现

  - 目标代码优化

  - 目标代码生成器设计实现

    

### 2.2 设计要求

- 在深入理解编译原理基本原理的基础上，对于选定的题目，以小组为单位，先确定设计方案；

- 设计系统的数据结构和程序结构，设计每个模块的处理流程。要求设计合理；

- 编程序实现系统，要求实现可视化的运行界面，界面应清楚地反映出系统的运行结果；

- 确定测试方案，选择测试用例，对系统进行测试；

- 运行系统并要通过验收，讲解运行结果，说明系统的特色和创新之处，并回答指导教师的提问；

- 提交课程设计报告。

  ##### 以下为本组设计要求：

  ​	给出一个源程序文件，作为编译器前端的输入，输出相关编译阶段的运行结果。

  - 词法分析阶段：TOKEN序列，关键字表、界符表、符号表系统。

  - 语法分析阶段：LL(1)产生式、分析表、语法分析栈

  - 符号表生成阶段：符号表系统

  - 中间代码生成阶段：四元式序列，符号表系统

  - 中间代码优化阶段：四元式序列、DAG图、优化完成的四元式序列

  - 目标代码生成阶段：符号表系统、四元式序列、目标代码

    

### 2.3 设计的文法结构

1. <函数定义> -><类型><标识符> ( <参数声明> ) { <函数块> } 

2. <类型> ->int | float | char | void | $

3. <因式> -> ( <表达式> ) | <标识符> | <数字> |<字符>

4. <表达式> -><因子><项>

5. <因子> -><因式><因式递归>

6. <因式递归> -> * <因式><因式递归> | / <因式><因式递归> | $ 

7. <项> -> + <因子><项> | - <因子><项> | $ 

8. <参数声明> -><声明><声明闭包> | $ 

9. <声明> -><类型><标识符><赋初值> |<标识符><赋初值>

10. <赋初值> -> = <右值> | $ 

11. <右值> -><表达式>

12. <声明闭包> -> , <声明><声明闭包> | $ 

13. <函数块> -><声明语句闭包><函数块闭包>

14. <声明语句闭包> -><声明语句><声明语句闭包> | $ 

15. <声明语句> -><声明> ;

16. <函数块闭包> -><赋值函数><函数块闭包> | <while循环><函数块闭包> | <条件语句><函数块闭包> | <函数返回><函数块闭包> |<cout语句><函数块闭包>|<cin语句><函数块闭包>| $ 

17. <赋值函数> -><标识符><赋值或函数调用>

18. <赋值或函数调用> -> = <右值> ; | ( <参数列表> ) ; 

19. <参数列表> -><参数><参数闭包>

20. <参数闭包> -> , <参数><参数闭包> | $ 

21. <参数> -><标识符> | <数字> | <字符串>

22. <While循环>->while(<逻辑表达式>){<函数块>}

23. <逻辑表达式> -><表达式><逻辑运算符><表达式>

24. <逻辑运算符> -> < | > | == |>=|<= 

25. <条件语句> -> if ( <逻辑表达式> ) { <函数块> } <否则语句>

26. <否则语句> -> else { <函数块> } | $ 

27. <函数返回> -> return <因式> ; 

28. <cout语句>-> cout << <标识符>; | cout<< <数字>; | cout<< <字符>;

29. <cin语句>-> cin>> <标识符>;

##### 产生式：

​	funcdef%type&id&(&parastate&)&{&funcblock&}&# 

​	type%int|float|char|void&# 

​	factor%(&exp&)|id|number|ch&# 

​	exp%divi&item&# 

​	divi%factor&faccycle&# 

​	faccycle%*&factor&faccycle|/&factor&faccycle|$&# 

​	item%+&divi&item|-&divi&item|$&# 

​	parastate%state&stateclo|$&# 

​	state%type&id&init|id&init&# 

​	init%=&rvalue|$&#

​	rvalue%exp&# 

​	stateclo%,&stateclo|$&# 

​	funcblock%staclo&funcbloclo&# 

​	staclo%statement&staclo|$&# 

​	statement%state&;&# 

​	funcbloclo%opera&funcbloclo|whilecycle&funcbloclo|condistate&funcbloclo|funcend

​		&funcbloclo|coutstate&funcbloclo|cinstate&funcbloclo|$&# 

​	opera%id&callstate&# 

​	callstate%=&rvalue&;|(&paralist&)&;&# 

​	paralist%para&paraclo&# 

​	paraclo%,&para&paraclo|$&# 

​	para%id|number|string&# 

​	whilecycle%while&(&logicexp&)&do&{&funcblock&}&we&# 

​	logicexp%exp&logicopera&exp&# 

​	logicopera%>|<|==|>=|<=&# 

​	condistate%if&(&logicexp&)&{&funcblock&}&nor&ie&# 

​	nor%else&{&funcblock&}|$&#

​	funcend%return&factor&;&# 

​	coutstate%cout&<&<&id&;&# 

​	cinstate%cin&>&>&id&;&# 

​	do%$&# 

​	we%$&# 

​	ie%$&#



## 3. 编译系统整体设计

### 3.1 整体设计流程图

![image-20200703151218432](C:\Users\无趣先生\AppData\Roaming\Typora\typora-user-images\image-20200703151218432.png)

### 3.2 中间代码生成(LR（0））

#### 3.2.1 功能

- 1.构建语义
- 2.重新导入二元式
- 3.获取动作序列
- 4.初始化四元式
- 5.获取动作序列位置
- 6.在已有动作序列的基础上生成四元式（自底向上）
- 7输出四元式
- 8.四元式的预处理及优化

#### 3.2.2 数据结构

struct quaternion {
int actid；
char id1[15]；
char id2[15]；
type type1；
type type2；
char id3[15]；

};

struct actsequence{
char name[15]；
char value1[15]；
float value2；
};

actsequence actionseq[100];

char actid[20][10]=
{"+"，"-"，"*”，"/"，">"，"<”，">="，"<="，"=="，"="，"if"，"else"，"ie"，
"while"，"do"，"we"，"return"，"cout"，"cin"，"#}；

int sem[1000];

#### 3.2.3 流程图



#### 3.2.4 算法

#### 



### 3.3 目标代码生成



## 4. 程序设计与实现

### 4.1 程序说明



### 4.2 实验结果



## 5. 收获、体会和建议

​		在夏季学期短短时间内要完成一个完整的编译器对我们整个小组都是巨大的挑战，对于我个人来说，本想着挑战一下自己，不去做之前实验做过的前端的部分，挑战一下中间代码生成，在刚开始的几天我和组里面的战友们一起设计了文法，在这个过程中反复推导和验证的过程中，对编译课程前面的知识进行了一个复习。到我自己的单独的部分时，和我之前的预想有些不太一样，很多东西都是需要自己去设计的，是在课上没有讲到过的，可能是我对中间代码的掌握还不够，设计出的一些语义动作并不能达到预期的效果，浪费了很多时间。然后在进过在网上搜索学习之后换了一种方法，并不是语法制导技术，现在正在尝试看能不能成功生成四元式。这对我来说是一个挑战，我也会尽力去做好自己的部分，同时和组里面其他同学一起协调好先把前端完善好。
