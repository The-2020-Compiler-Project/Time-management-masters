# 编译第一次过程报告



------



## 设计分工：



组长学号及姓名：20184317彭明均



分工：文法设计、数据结构设计、语法分析（LL1）、基于DAG的中间代码优化、部分目标代码生成



组员1学号及姓名：20184454谢一帆



分工：文法设计、符号表组织、部分目标代码生成



组员2学号及姓名：20184540梁俊涛



分工：文法设计、中间代码生成（LR0）、部分目标代码生成



组员3学号及姓名：20184390杨子江



分工：文法设计、词法分析、部分目标代码生成







## 1. 摘要



		编译器是一个便于人编写、阅读和维护的高级计算机语言翻译为计算机能解读、运行的低阶机器语言或者汇编语言的程序。编译是从源代码（通常为高级语言）到能直接被计算机或者虚拟机执行的目标代码（通常为汇编语言或者机器语言）的翻译过程。



 - 编译器的概念



  		编译器是一个便于人编写、阅读和维护的高级计算机语言翻译为计算机能解读、运行的低阶机器语言或者汇编语言的程序。编译器将源程序作为输入，翻译产生使用目标语言的等价程序。源代码一般为高级语言，而目标代码则是汇编语言或者机器语言。



 - 编译器的种类



  		编译器可以生成用来在与编译器本身所在的计算机和操作系统相同的环境下运行的目标代码，这种编译器又叫做“本地”编译器。另外，编译器也可以生成用来在其他平台上运行的目标代码，这种编译器又叫做交叉编译器。交叉编译器在生成新的硬件平台时非常有用。“源码到源码编译器”是指用一种高级语言作为输入，输出也是高级语言的编译器。



 - 本编译器的相关概述



  		编译程序的工作一般可以分为五个阶段：词法分析、语法分析、语义分析、中间代码产生和优化、目标代码生成。每个阶段又在功能上是相对独立的，它一方面从上一阶段获取分析的结果来进行分析，另一方面又将结果传送给下一阶段。由编译程序的五个阶段就对应了编译系统的结构，这五个对应阶段分为编译器的前端和后端。



  		语法分析器将词法分析的结果作为输入，并对其进行语法分析。本编译器语法分析采用LL(1)分析法，语法分析器把语法单元作为输出供语义分析器来使用。



- 环境



 Visual Studio 2019



- 目标代码



 8086汇编语言



 



## 2. 课程设计任务及要求



### 2.1 设计任务



- 在下列内容中任选其一：



 - 一个简单文法的编译器前端的设计与实现。

 - 一个简单文法的编译器后端的设计与实现。

 - 一个简单文法的编译器的设计与实现。

 - 自选一个感兴趣的与编译原理有关的问题加以实现，要求难度相当。



- 本组选择题目：



 ****一个简单文法的编译器的设计与实现。****



 - 定义一个简单程序设计语言文法



 - 扫描器设计实现



 - 语法分析器设计实现



 - 符号表设计



 - 符号表生成器设计



 - 中间代码设计



 - 中间代码生成器设计



 - 中间代码优化



 - 中间代码优化实现



 - 目标代码优化



 - 目标代码生成器设计实现



   



### 2.2 设计要求



- 在深入理解编译原理基本原理的基础上，对于选定的题目，以小组为单位，先确定设计方案；



- 设计系统的数据结构和程序结构，设计每个模块的处理流程。要求设计合理；



- 编程序实现系统，要求实现可视化的运行界面，界面应清楚地反映出系统的运行结果；



- 确定测试方案，选择测试用例，对系统进行测试；



- 运行系统并要通过验收，讲解运行结果，说明系统的特色和创新之处，并回答指导教师的提问；



- 提交课程设计报告。



 ##### 以下为本组设计要求：



 	给出一个源程序文件，作为编译器前端的输入，输出相关编译阶段的运行结果。



 - 词法分析阶段：TOKEN序列，关键字表、界符表、符号表系统。



 - 语法分析阶段：LL(1)产生式、分析表、语法分析栈



 - 符号表生成阶段：符号表系统



 - 中间代码生成阶段：四元式序列，符号表系统



 - 中间代码优化阶段：四元式序列、DAG图、优化完成的四元式序列



 - 目标代码生成阶段：符号表系统、四元式序列、目标代码



   



### 2.3 设计的文法结构



1. <函数定义> -><类型><标识符> ( <参数声明> ) { <函数块> } 



2. <类型> ->int | float | char | void | $



3. <因式> -> ( <表达式> ) | <标识符> | <数字> |<字符>



4. <表达式> -><因子><项>



5. <因子> -><因式><因式递归>



6. <因式递归> -> * <因式><因式递归> | / <因式><因式递归> | $ 



7. <项> -> + <因子><项> | - <因子><项> | $ 



8. <参数声明> -><声明><声明闭包> | $ 



9. <声明> -><类型><标识符><赋初值> |<标识符><赋初值>



10. <赋初值> -> = <右值> | $ 



11. <右值> -><表达式>



12. <声明闭包> -> , <声明><声明闭包> | $ 



13. <函数块> -><声明语句闭包><函数块闭包>



14. <声明语句闭包> -><声明语句><声明语句闭包> | $ 



15. <声明语句> -><声明> ;



16. <函数块闭包> -><赋值函数><函数块闭包> | <while循环><函数块闭包> | <条件语句><函数块闭包> | <函数返回><函数块闭包> |<cout语句><函数块闭包>|<cin语句><函数块闭包>| $ 



17. <赋值函数> -><标识符><赋值或函数调用>



18. <赋值或函数调用> -> = <右值> ; | ( <参数列表> ) ; 



19. <参数列表> -><参数><参数闭包>



20. <参数闭包> -> , <参数><参数闭包> | $ 



21. <参数> -><标识符> | <数字> | <字符串>



22. <While循环>->while(<逻辑表达式>){<函数块>}



23. <逻辑表达式> -><表达式><逻辑运算符><表达式>



24. <逻辑运算符> -> < | > | == |>=|<= 



25. <条件语句> -> if ( <逻辑表达式> ) { <函数块> } <否则语句>



26. <否则语句> -> else { <函数块> } | $ 



27. <函数返回> -> return <因式> ; 



28. <cout语句>-> cout << <标识符>; | cout<< <数字>; | cout<< <字符>;



29. <cin语句>-> cin>> <标识符>;



##### 产生式：



	funcdef%type&id&(&parastate&)&{&funcblock&}&# 



	type%int|float|char|void&# 



	factor%(&exp&)|id|number|ch&# 



	exp%divi&item&# 



	divi%factor&faccycle&# 



	faccycle%*&factor&faccycle|/&factor&faccycle|$&# 



	item%+&divi&item|-&divi&item|$&# 



	parastate%state&stateclo|$&# 



	state%type&id&init|id&init&# 



	init%=&rvalue|$&#



	rvalue%exp&# 



	stateclo%,&stateclo|$&# 



	funcblock%staclo&funcbloclo&# 



	staclo%statement&staclo|$&# 



	statement%state&;&# 



	funcbloclo%opera&funcbloclo|whilecycle&funcbloclo|condistate&funcbloclo|funcend



		&funcbloclo|coutstate&funcbloclo|cinstate&funcbloclo|$&# 



	opera%id&callstate&# 



	callstate%=&rvalue&;|(&paralist&)&;&# 



	paralist%para&paraclo&# 



	paraclo%,&para&paraclo|$&# 



	para%id|number|string&# 



	whilecycle%while&(&logicexp&)&do&{&funcblock&}&we&# 



	logicexp%exp&logicopera&exp&# 



	logicopera%>|<|==|>=|<=&# 



	condistate%if&(&logicexp&)&{&funcblock&}&nor&ie&# 



	nor%else&{&funcblock&}|$&#



	funcend%return&factor&;&# 



	coutstate%cout&<&<&id&;&# 



	cinstate%cin&>&>&id&;&# 



	do%$&# 



	we%$&# 



	ie%$&#







\## 3. 编译系统整体设计



\### 3.1 整体设计流程图



<img src="C:\Users\演员\AppData\Roaming\Typora\typora-user-images\image-20200629173517227.png" alt="image-20200629173517227" align='left' style="zoom: 67%;" />



\### 3.2 语法分析(LL(1))



#### 3.2.1 功能

- 构建活动记录表

- 构建符号表

- 构建函数表

- 构建长度表

- 添加活动记录

- 添加变量表

- 符号表预处理

- 添加函数表

- 添加参数表

- 构建活动记录与变量表（二合一）



#### 3.2.2 数据结构



在编译程序中，符号表项的组织传统上采用三种构造方法：

线性组织

排列组织及二分法

散列组织

线性表按符号扫描的顺序有序填入，但在查询时效率较低；排列表按首字符大小来填写符号表，查询效率较高，但填写时实现较复杂。因此，散列表可以通过一定的散列函数来实现符号表的高效填写和查询。至此，我们可以写出符号表总体的数据结构：

char var[16][15] = {};/**变量表**/

enum TYP{in,real,ch,b,error1};/**类型，包括int，float,char,bool型**/

enum CAT{f,c,t,d,v,vn,vf,error2};/**种类，包括f函数，c常量，t类型，d域名，v变量，vn换名形参，vf，赋值形参**/

enum ADDR{PFINFL,LENL,VALL,error3};/**地址表，包括函数表，活动记录表**/

struct duality {/**二元式数据结构**/

  Kind kind;

  char value1[25];

  int value2;

};

duality Token[1000];/**词法序列（二元式结构）**/



struct SYNBL {/**符号表**/

  char name[15];

  TYP type;

  CAT kind;

  ADDR addr;

};



struct pfinfl {/**函数表**/

  int level;

  int off;

  int fn;

  SYNBL para[5];/**参数表**/

  int entry;

};



struct vall {/**活动记录表，采用链表结构**/

  char name[15];

  char nextname[15];//name1

  int low;

  int up;

  struct vall *next;

};



struct lenl {/**长度表**/

  char name[10];

  int length;

};





#### 3.2.3 流程图



符号表是标识符的动态语义词典，属于编译中语义分析的知识库；主要内容：

⑴ 名字 — 标识符源码，用作查询关键字；

⑵ 类型 -- 该标识符的数据类型及其相关信息；

⑶ 种类 -- 该标识符在源程序中的语义角色；

⑷ 地址 -- 与值单元相关的一些信息；

在我设计的符号表生成器中，填写阶段主要使用词法序列，来实现符号表的动态填写。我将填写符号表的过程分为四个阶段：

  明确当前符号表的作用域，将作用域名称填入符号表集合。

  填写当前作用域的符号表，插入的动作主要在说明符子程序，这是对普通变量的填写。

  填写当前作用域内的数组类型，由于数组类型相比于其他变量类型较为特殊，需要单独考虑它的填写过程。

  完成符号表的填写，使当前作用域和临时变量回归到初始状态。

![Image text](https://github.com/cse0001/Time-management-masters/blob/4454/%E8%BF%87%E7%A8%8B%E6%8A%A5%E5%91%8A/02%E8%AE%A1%E7%AE%97%E6%9C%BA1804-%E8%B0%A2%E4%B8%80%E5%B8%86-20184454/1.jpg)

#### 3.2.4 算法

void ADD_vall(vall* head, int t1, int t2, char**id,char**id1) {/**添加活动记录**/

void PRINT_vall(vall**head) {/***打印活动记录表***/*

*void Finish_fun(pfinfl**fun)//函数表预处理

void Finsh_SYNBL() {/**完成符号表**/

void Write_SYNBL(SYNBL**out,int flag) //写入符号表*

*void PRINT_SYNBL(pfinfl**function) {/**打印符号表、函数表、活动记录表、长度表**/

void Begin_SYNBL() //开始构建符号表

void ADD_Identifier (char id[16][15],char*cmp,int flag) {/**标识符表元素添加**/



#### 3.2.5 运行截图

![Image text]([https://github.com/cse0001/Time-management-masters/blob/4454/%E8%BF%87%E7%A8%8B%E6%8A%A5%E5%91%8A/02%E8%AE%A1%E7%AE%97%E6%9C%BA1804-%E8%B0%A2%E4%B8%80%E5%B8%86-20184454/2.jpg](https://github.com/cse0001/Time-management-masters/blob/4454/过程报告/02计算机1804-谢一帆-20184454/2.jpg))

### 3.3 目标代码生成

#### 3.3.1 符号表预处理

##### 3.3.1.1 功能

- 对符号表进行预处理，为生成中间代码做准备
- 根据活动记录，生成目标代码生成所需的符号表
- 打印符号表，显示名称，类型，种类以及存储上下界

##### 3.3.1.2 数据结构

struct actrecord {/*标识符活动记录,类型登记*/

  char id[15];

  int low;

  int up;

  typ1 s1;

  typ2 s2;

};

enum typ1{in,fl,chars,boo};

enum typ2{var,fu};

##### 3.3.1.3 算法

typ1 kindget(char cmp[15]) //获取类别

void symbolprep() {/*对符号表进行预处理，为生成中间代码做准备*/

void symprint() //打印

## 4. 程序设计与实现



### 4.1 程序说明







### 4.2 实验结果







## 5. 收获、体会和建议