# 编译第一次过程报告



------



## 设计分工：



组长学号及姓名：20184317彭明均



分工：文法设计、数据结构设计、语法分析（LL1）、基于DAG的中间代码优化、部分目标代码生成



组员1学号及姓名：20184454谢一帆



分工：文法设计、符号表组织、部分目标代码生成



组员2学号及姓名：20184540梁俊涛



分工：文法设计、中间代码生成（LR0）、部分目标代码生成



组员3学号及姓名：20184390杨子江



分工：文法设计、词法分析、部分目标代码生成







## 1. 摘要



​		编译器是一个便于人编写、阅读和维护的高级计算机语言翻译为计算机能解读、运行的低阶机器语言或者汇编语言的程序。编译是从源代码（通常为高级语言）到能直接被计算机或者虚拟机执行的目标代码（通常为汇编语言或者机器语言）的翻译过程。



 - 编译器的概念



  		编译器是一个便于人编写、阅读和维护的高级计算机语言翻译为计算机能解读、运行的低阶机器语言或者汇编语言的程序。编译器将源程序作为输入，翻译产生使用目标语言的等价程序。源代码一般为高级语言，而目标代码则是汇编语言或者机器语言。



 - 编译器的种类



  		编译器可以生成用来在与编译器本身所在的计算机和操作系统相同的环境下运行的目标代码，这种编译器又叫做“本地”编译器。另外，编译器也可以生成用来在其他平台上运行的目标代码，这种编译器又叫做交叉编译器。交叉编译器在生成新的硬件平台时非常有用。“源码到源码编译器”是指用一种高级语言作为输入，输出也是高级语言的编译器。



 - 本编译器的相关概述



  		编译程序的工作一般可以分为五个阶段：词法分析、语法分析、语义分析、中间代码产生和优化、目标代码生成。每个阶段又在功能上是相对独立的，它一方面从上一阶段获取分析的结果来进行分析，另一方面又将结果传送给下一阶段。由编译程序的五个阶段就对应了编译系统的结构，这五个对应阶段分为编译器的前端和后端。



  		语法分析器将词法分析的结果作为输入，并对其进行语法分析。本编译器语法分析采用LL(1)分析法，语法分析器把语法单元作为输出供语义分析器来使用。



- 环境



 Visual Studio 2019



- 目标代码



 8086汇编语言



 



## 2. 课程设计任务及要求



### 2.1 设计任务



- 在下列内容中任选其一：



 - 一个简单文法的编译器前端的设计与实现。

 - 一个简单文法的编译器后端的设计与实现。

 - 一个简单文法的编译器的设计与实现。

 - 自选一个感兴趣的与编译原理有关的问题加以实现，要求难度相当。



- 本组选择题目：



 ****一个简单文法的编译器的设计与实现。****



 - 定义一个简单程序设计语言文法



 - 扫描器设计实现



 - 语法分析器设计实现



 - 符号表设计



 - 符号表生成器设计



 - 中间代码设计



 - 中间代码生成器设计



 - 中间代码优化



 - 中间代码优化实现



 - 目标代码优化



 - 目标代码生成器设计实现



   



### 2.2 设计要求



- 在深入理解编译原理基本原理的基础上，对于选定的题目，以小组为单位，先确定设计方案；



- 设计系统的数据结构和程序结构，设计每个模块的处理流程。要求设计合理；



- 编程序实现系统，要求实现可视化的运行界面，界面应清楚地反映出系统的运行结果；



- 确定测试方案，选择测试用例，对系统进行测试；



- 运行系统并要通过验收，讲解运行结果，说明系统的特色和创新之处，并回答指导教师的提问；



- 提交课程设计报告。



 ##### 以下为本组设计要求：



 	给出一个源程序文件，作为编译器前端的输入，输出相关编译阶段的运行结果。



 - 词法分析阶段：TOKEN序列，关键字表、界符表、符号表系统。



 - 语法分析阶段：LL(1)产生式、分析表、语法分析栈



 - 符号表生成阶段：符号表系统



 - 中间代码生成阶段：四元式序列，符号表系统



 - 中间代码优化阶段：四元式序列、DAG图、优化完成的四元式序列



 - 目标代码生成阶段：符号表系统、四元式序列、目标代码



   



### 2.3 设计的文法结构



1. <函数定义> -><类型><标识符> ( <参数声明> ) { <函数块> } 



2. <类型> ->int | float | char | void | $



3. <因式> -> ( <表达式> ) | <标识符> | <数字> |<字符>



4. <表达式> -><因子><项>



5. <因子> -><因式><因式递归>



6. <因式递归> -> * <因式><因式递归> | / <因式><因式递归> | $ 



7. <项> -> + <因子><项> | - <因子><项> | $ 



8. <参数声明> -><声明><声明闭包> | $ 



9. <声明> -><类型><标识符><赋初值> |<标识符><赋初值>



10. <赋初值> -> = <右值> | $ 



11. <右值> -><表达式>



12. <声明闭包> -> , <声明><声明闭包> | $ 



13. <函数块> -><声明语句闭包><函数块闭包>



14. <声明语句闭包> -><声明语句><声明语句闭包> | $ 



15. <声明语句> -><声明> ;



16. <函数块闭包> -><赋值函数><函数块闭包> | <while循环><函数块闭包> | <条件语句><函数块闭包> | <函数返回><函数块闭包> |<cout语句><函数块闭包>|<cin语句><函数块闭包>| $ 



17. <赋值函数> -><标识符><赋值或函数调用>



18. <赋值或函数调用> -> = <右值> ; | ( <参数列表> ) ; 



19. <参数列表> -><参数><参数闭包>



20. <参数闭包> -> , <参数><参数闭包> | $ 



21. <参数> -><标识符> | <数字> | <字符串>



22. <While循环>->while(<逻辑表达式>){<函数块>}



23. <逻辑表达式> -><表达式><逻辑运算符><表达式>



24. <逻辑运算符> -> < | > | == |>=|<= 



25. <条件语句> -> if ( <逻辑表达式> ) { <函数块> } <否则语句>



26. <否则语句> -> else { <函数块> } | $ 



27. <函数返回> -> return <因式> ; 



28. <cout语句>-> cout << <标识符>; | cout<< <数字>; | cout<< <字符>;



29. <cin语句>-> cin>> <标识符>;



##### 产生式：



​	funcdef%type&id&(&parastate&)&{&funcblock&}&# 



​	type%int|float|char|void&# 



​	factor%(&exp&)|id|number|ch&# 



​	exp%divi&item&# 



​	divi%factor&faccycle&# 



​	faccycle%*&factor&faccycle|/&factor&faccycle|$&# 



​	item%+&divi&item|-&divi&item|$&# 



​	parastate%state&stateclo|$&# 



​	state%type&id&init|id&init&# 



​	init%=&rvalue|$&#



​	rvalue%exp&# 



​	stateclo%,&stateclo|$&# 



​	funcblock%staclo&funcbloclo&# 



​	staclo%statement&staclo|$&# 



​	statement%state&;&# 



​	funcbloclo%opera&funcbloclo|whilecycle&funcbloclo|condistate&funcbloclo|funcend



​		&funcbloclo|coutstate&funcbloclo|cinstate&funcbloclo|$&# 



​	opera%id&callstate&# 



​	callstate%=&rvalue&;|(&paralist&)&;&# 



​	paralist%para&paraclo&# 



​	paraclo%,&para&paraclo|$&# 



​	para%id|number|string&# 



​	whilecycle%while&(&logicexp&)&do&{&funcblock&}&we&# 



​	logicexp%exp&logicopera&exp&# 



​	logicopera%>|<|==|>=|<=&# 



​	condistate%if&(&logicexp&)&{&funcblock&}&nor&ie&# 



​	nor%else&{&funcblock&}|$&#



​	funcend%return&factor&;&# 



​	coutstate%cout&<&<&id&;&# 



​	cinstate%cin&>&>&id&;&# 



​	do%$&# 



​	we%$&# 



​	ie%$&#









#### 3.2.1 功能

- 读入源程序

- 对源程序做预处理

- 生成二元式序列

- 根据二元式序列填符号表

- 将token序列保存到2进制文件中

  词法分析是将字符序列转换为token序列的过程。在这一阶段我们需要从左往右依次扫描源程序中的字符，然后依据单词的构词法则生成token序列。设计的词法分析器需要能够较为完善的识别出不同的单词，并且能够按照token序列实现填表操作。



#### 3.2.2 数据结构



![image-20200703130126239](C:\Users\MI\AppData\Roaming\Typora\typora-user-images\image-20200703130126239.png)

二元式包含kind、value1和value2三项，但在实际使用时只会在value1和value2中选取一个。kind存放种类，value2储存固定表中单词所对序列（关键字表、界符表），value1储存其他单词或数字的值。



#### 3.2.3 流程图

<img src="C:\Users\MI\AppData\Roaming\Typora\typora-user-images\image-20200703165928627.png" alt="image-20200703165928627" align='left'  />

#### 3.2.4 算法

static void init_twoele(two_elements*token){//初始化二元式和变量表

void prep(char ch) {//对源程序预处理

int is_keyword(char*cmp) {//查询获得单词是否为关键字，是则返回序号

void add_to_varT(char*cmp) {//加入变量表

static void scanner() {//词法扫描

预处理部分是对源程序中的注释进行过滤，操作方法为遇到//的话跳过一整行，遇到/*的话进行跳过，直到遇到下一个 */则结束。

具体的词法分析算法如下：

关键字和标识符：首先判断是否是字母开头，如果是的话就查看关键字表。如果查询到的话，那么该单词为关键字否则就是标识符。同时需要注意，如果是以下划线开头的，那么就是标识符。

字符：由于C语言中的字符都会被单引号包含，所以首先识别是否有单引号，有的话就寻找下一个单引号，寻找成功的话两个单引号中间的部分就是字符。

字符串：类比与字符的判断，字符串的判断是基于双引号。当识别到一个双引号时，就继续读，直到下一个双引号出现时，两个双引号中间的部分就是字符串。

界符：界符直接使用switch进行判断即可。需要注意的是，<,>,/等会出现<<,>>,//等需要多次判断的情况。

数字：数字的识别需要注意的是，我们要保存的是一个数字，而不是一个数组，所以应该将读取到的数组中按位*10来变成一个数字。遇到小数点之后，就将后续读入的数字按位/10变成小数部分。

#### 3.2.5 运行截图







## 4. 程序设计与实现



### 4.1 程序说明







### 4.2 实验结果







## 5. 收获、体会和建议
