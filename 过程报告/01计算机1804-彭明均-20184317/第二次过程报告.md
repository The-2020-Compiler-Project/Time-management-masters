# 编译第一次过程报告

## 设计分工：

组长学号及姓名：20184317彭明均

分工：文法设计、数据结构设计、语法分析（LL1）、基于DAG的中间代码优化、部分目标代码生成

组员1学号及姓名：20184454谢一帆

分工：文法设计、符号表组织、部分目标代码生成

组员2学号及姓名：20184540梁俊涛

分工：文法设计、中间代码生成（LR0）、部分目标代码生成

组员3学号及姓名：20184390杨子江

分工：文法设计、词法分析、部分目标代码生成

### 3.3 中间代码优化

#### 3.3.4 算法

<img src="C:\Users\演员\AppData\Roaming\Typora\typora-user-images\image-20200707163621467.png" alt="image-20200707163621467" align='left'  />

​		对于DAG方法，每读一个四元式将在DAG图上产生相应的DAG节点，其中的DAG对应序号是节点的编号，即该节点是图中的哪个节点；ope_ch即该节点的操作符；level是树层次；因为一个节点可能会有多个附标记或没有，所以我用c++的标准库函数里的list链表来定义附标记，每一个附标记对应链表里的一个元素；Left和Right则对应一个节点的左右子节点（若没有则左右子节点直接赋值为空）。

​		接着，我定义了一个DAG_node；来存一个个DAG节点节点之间的连接关系用DAG图的Left和Right来衔接，一个DAG图可以理解成优化后的的基本块四元式堆叠。

​		我们按顺序从划分了基本块的四元式直接逐个取出，取出四元式后先判断B和C节点是否存在，若不存在则先生成B、C节点；根据操作符来将四元式进行分类。

​		首先根据已经划分的基本块直接生成一个DAG图，而后在其基础上再进行优化，最后导出完成优化的四元式，而原四元式中被删改部分在回输到文件中时则直接跳过之。

​		下面是根据操作符进行优化。

​		如果四元式是+，\-，*，/时，再判断DAG节点的左子树和右子树是不是同时为常数，如果是的话说明我们取得的四元式是常数类型，此时我们需要先计算出常数运算结果值，然后将结果值绘入DAG图中，并且直接将该节点的左子树和右子树直接空置，因为我们是针对词法分析步骤产生的Token进行操作的，所以在这里需要将浮点型的运算结果求出其相应的Token并压入常数表里；之后判断这个运算结果称其为temptoken和四元式结果A在已生成的DAG图里是否存在，如果存在则返回相应的位置，否则返回0；根据这个返回值来判断结果A在DAG图里是否已经存在并且不是主节点，如果是要将其从附标记中删除。

​		如果是+，\-，*，/且运算对象不均为常数，则说明我们取得的四元式是A=B+3这种类型，此时先查找DAG表里是否有节点A且在附标记上，若有则要将其从副标记中删除；再遍历整个DAG表看是否有一个节点它的操作符是+，左右节点是B和3，如果有则说明之前有过表达式如D=B+3，此时只需要把A附加在B之上并判断是否需要调整B和A的顺序；否则则需要另定义节点A，然后调用之前说过的查找函数来从DAG表里查是否有节点B、3，如果有则将其标号赋给A的左右节点，否则则再生成B、3节点然后赋给A。

​		如果是赋值号=如A=B类型，则先查找DAG表里是否有节点A且在附标记上，若有则要将其从附标记中删除，然后判断节点B是否存在，若存在直接将A附加到B之上并判断优先级来决定是否需要调整位置，如果节点B不存在则先添加节点B再执行附加过程。

​		如果以上都不是则说明此时读出来的四元式不是表达式语句，可能是if，while之类的，由于在划分基本块时已经自动忽略这些四元式，如果再次说明可以很容易知道程序优化部分出错，发生了越界现象，直接报错即可。

​		当执行到重组时，遍历DAG图的每个节点，如果该节点有附标记则遍历其附加标记，若某个附加标记是非临时变量则将A=B压入一个新的四元式里，最终返回该四元式。

​		如果该节点非叶节点说明他有左右孩子，则根据该节点的操作符来生成对应的A=BwC压入新的四元式里。

#### 3.3.5 程序截图

![image-20200707170439402](C:\Users\演员\AppData\Roaming\Typora\typora-user-images\image-20200707170439402.png)

### 3.4 目标代码生成

#### 3.4.1 功能

- 四元式预处理

- 符号表预处理

- 调用中间代码优化

- 获取完成优化的四元式

- 生成目标代码

  大多数编译程序不产生绝对地址的机器代码，而是以汇编语言程序作为输出使代码生成阶段变得更加容易。此外，指令集的选择以及指令的执行速度都是重要因素。

#### 3.4.2 数据结构

<img src="C:\Users\演员\AppData\Roaming\Typora\typora-user-images\image-20200707180154707.png" alt="image-20200707180154707" align='left'  />

#### 3.4.3 流程图

<img src="C:\Users\演员\AppData\Roaming\Typora\typora-user-images\image-20200709100152691.png" alt="image-20200709100152691" align='left'  />

#### 3.4.4 算法

进入目标代码生成后首先对符号表预处理，然后对四元式预处理，调用四元式优化。

然后正式开始目标代码生成，打开优化完成的四元式文件后，依次读入四元式，同时打开目标代码文件，向其中写入目标代码。

首先是通过符号表填写定义变量以及汇编语言预置部分代码。

然后开始读取四元式，判断四元式的类型，赋值语句，输入输出，逻辑表达式，算术表达式等等并通过判断数据类型，然后将他们翻译成目标代码，反之若类型不匹配则报错。

#### 3.4.5 程序截图

待翻译源代码如下：

<img src="C:\Users\演员\AppData\Roaming\Typora\typora-user-images\image-20200707185009808.png" alt="image-20200707185009808" align='left'  />

四元式预处理：

<img src="C:\Users\演员\AppData\Roaming\Typora\typora-user-images\image-20200707185121809.png" alt="image-20200707185121809" align='left'  />

预处理的符号表：

<img src="C:\Users\演员\AppData\Roaming\Typora\typora-user-images\image-20200707185244784.png" alt="image-20200707185244784" align='left'  />

生成的目标代码：

<img src="C:\Users\演员\AppData\Roaming\Typora\typora-user-images\image-20200707185319555.png" alt="image-20200707185319555" align='left'  />

<img src="C:\Users\演员\AppData\Roaming\Typora\typora-user-images\image-20200707185409646.png" alt="image-20200707185409646" align='left'  />

<img src="C:\Users\演员\AppData\Roaming\Typora\typora-user-images\image-20200707185502929.png" alt="image-20200707185502929" align='left'  />

<img src="C:\Users\演员\AppData\Roaming\Typora\typora-user-images\image-20200707185542211.png" alt="image-20200707185542211" align='left'  />

<img src="C:\Users\演员\AppData\Roaming\Typora\typora-user-images\image-20200707185704867.png" alt="image-20200707185704867" align='left'  />

## 4. 程序设计与实现

### 4.1 程序说明

​		本程序实现的简单编译器中，变量定义只能有int、float、char、string型，最后在目标代码生成过程中允许出现bool型，其他变量类型均不支持，然后便是支持函数返回类型为int、float、char、void型，暂不支持指针等类型，本编译器还支持if判断语句，while循环语句，+、-、*、/运算，以及支持>、<、>=、<=、==五个逻辑运算，也支持赋值运算，另外也实现了对cin、cout的输入输出。做到了类型检查和重定义的判断。

​		语法分析部分采用的是LL1分析方法，这是一种自上而下的语法分析法，又称为预测分析法，语法分析器部分实现了自动求first集合和follow集合，采用的是递归程序获得select集合，在实现对产生式完全扫描以后，便可以获得一张完整的分析表，表中标注了是否为预测以及对应的产生式序列，而后进行语法分析，通过于获得的分析表进行比对，进行入栈出栈，匹配到相同的则认为匹配成果，当文法匹配成功，同时单词也匹配成功的时候，认为语法分析完成，语法无错误，否则报错。

​		中间代码优化部分是对填装完毕的中间代码的再处理，也就是减少无用式子，给目标代码的生成提供便利，先进行基本块划分，而后采取的是DAG图优化，即无环有向图优化，顺序是构建DAG图（无环有向图），减少无用分支，或删改部分同义分支，完成DAG图改造后便又重新由树组装四元式，组装好的四元式又再次重新输出到文件中。

​		目标代码生成部分较长，也并不仅仅包含目标代码生成部分，在这个部分文件中，同时需要对前述获得的符号表，中间代码进行再处理，以得到符号目标代码生成所用的符号表和中间代码，再进行预处理完成之后，具体为根据四元式动作，按顺序依次生成目标代码，需要依据不同的四元式动作每个采取不同的操作方法，生成相应目标代码。

​		测试部分采用的Dosbox软件，最后进行的是对目标代码的正确性检验以及运行，运行通过且符合源程序实际操作即认为编译器任务完成。

### 4.2 实验结果

输入1后计算1至100的累加值为5050，十六进制为13BAH

<img src="C:\Users\演员\AppData\Roaming\Typora\typora-user-images\image-20200707193236508.png" alt="image-20200707193236508" align='left'  />

## 5. 收获、体会和建议

​		相比于编译器前端的开发，后端的开发就显得更加考验团队协作的能力。在完成前端开发之后，我们高兴了一阵，但是知道接下来面临着是我们不熟悉的编译器后端的相应开发，在我实现中间代码优化的过程过程中也遇见了不少的麻烦，首先我想到的是上课所讲的方法，生成DAG图，并进行优化。同时，我在课设动员大会上也听到老师说可以采用更加好的优化算法，但是在我查询了部分资料过后，还是决定从基础做起，因为我个人对于后端并不像前端那么熟悉。然后当我开始做中间代码优化的过程中，我又遇见了相应的麻烦，采用哪些优化措施，例如常值合并等，以及应该采用何种方式建立DAG图，最终我翻阅上课所采用的PPT找到了答案。

<img src="C:\Users\演员\AppData\Roaming\Typora\typora-user-images\image-20200707194607467.png" alt="image-20200707194607467" align='left' style="zoom:80%;" />

​		最后便是我们组一起开发的目标代码生成，但是由于这其实算是单个模块，可以由一个人开发，但是我们组已经分别将前端和目标代码生成优化分工完成了，剩下的目标代码生成便相对平均的分到大家头上，相比于前面的模块实现，多人制作目标代码生成更加考验团队的合作能力，所以我们便采用了这种分工方式。

​		我个人分到的是四元式预处理，使之更加符合目标代码生成形式，以及条件语句，循环语句，输入输出语句和函数返回return。

​		首先是四元式预处理，由于在目标代码翻译过程中有多种四元式，普通定义变量，形参等，所以需要将他们规范成统一的形式。然后是条件语句，当得到if判断四元式，我就将相应的标记存入目标代码中，其他循环语句类似。输入输出则是采用固定形式将输入输出的值存放到相应的寄存器中，最后调用DOS功能输入输出。

​		